[toc]

复合数据类型是由基本数据类型以各种方式组合而构成的，就像分子由原子构成的一样。
四种复合数据类型: 数组、slice、map、和结构体。

数组和结构体都是聚合类型，他们的值由内存中一组变量构成。数组的元素具有相同的类型，而结构体中元素的数据类型则可以不同。数组和结构体长度都是固定的，反之 slice、map都是动态数据结构，他们的长度在元素添加到结构中可以动态增长。

## 1 数组
数组具有固定长度，且拥有零个或者多个相同数据类型元素的序列。由于数组的长度固定，所以在 Go 里面很少直接使用。slice 的长度可以增长或缩短，在很多场合下使用更多。然而，在理解 slice之前，我们需要先理解 数组。

数组中的每个元素都是通过索引来访问的，索引从 0 到 数组长度减 1。Go 内置函数 len 可以返回数组中的元素个数。
```go
package main

import "fmt"

func main(){
	var a [3]int                // 定义3个整数的数组
	fmt.Println(a[0])           // 打印数组的第一个元素
	fmt.Println(a[len(a) -1])   // 打印数组的最后一个元素
	for i, v := range a{        // 输出索引和元素
		fmt.Println(i,v)
	}
	for _,v := range a{         // 仅输出数组元素
		fmt.Println(v)
	}
}
```
默认情况下，一个新数组中的元素初始值为元素类型的零值，对于数字来说，就是0。也可以根据数组字面量根据一组值来初始化一个数组。
```go
var q [3]int = [3]int{1,2,3}
var r [3]int = [3]int{1,2}
fmt.Println(r[2]) // 0
```
在数组字面量中, 如果省略号 "..." 出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定。以上数组 q 的定义可以简化:
```go
q := [...]int{1,2,3}
fmt.Printf("%T\n", q) //[3]int
```
数组的长度是数组类型的一部分，所以[3]int 和 [4]int 是两种不同的数组类型。数组的长度必须是常量表达式，也就是说，这个值在程序编译时就可以确定。
```go
q := [3]int{1,2,3}
q = [4]int{1,2,3,4} // 编译错误，不可以将[4]int 赋值给 [3]int
fmt.Println(q)
```
如我们所见，数组、slice、map和结构体的字面语法都是相似的。上面的例子是按照顺序给出一组值，也可以如下面给出一组值, 这一组值同样具有索引和索引对应的值。
```go
type Currency int
const (
    USD Currency = iota
    EUR
    GBP
    RMB
)
symbol := [...]string{USD: "$", EUR: "XX", GBP: "AA", RMB: "aax"}
fmt.Println(RMB, symbol[RMB]) // 3, aax
```
在这种情况下，索引可以按照任意顺序出现，并且有的时候还可以省略。和上面一样，没有指定值的索引位置的元素默认被赋予数组元素类型的零值。例如
```go
r := [...]int{8: -1}
fmt.Println(r) // [0 0 0 0 0 0 0 0 -1]
```
定义了一个拥有9个元素的数组 r ，除了最后一个元素是 -1 外，该数组中的其他元素值都是 0。
如果一个数组的元素类型是可比较的，那么这个数组也是可比较的，这样我们就可以直接使用 == 操作符来比较两个数组，比较的结果是两边元素的值是否完全相同。使用 != 来比较两个数组是否不同。
```go
	a := [2]int{1,2}
	b := [...]int{1,2}
	c := [2]int{1,3}
	d := [3]int{1,2}
	fmt.Println(a==b,a==c,b==c) // true false false
	fmt.Println(a==d) // 编译错误，无法比较 [2]int == [3]int
```

举一个更有意义的例子，crypto/sha256 包里面的函数 Sum256 用来为存储在任意字节 slice 中的消息使用 SHA256 加密散列算法生成一个摘要。摘要的信息是256位，即[32]byte, 如果两个摘要信息相同，那么很有可能这两条原始信息是相同的，如果这两个摘要信息不同，那么这两条原始消息就是不同的。下面的程序输出并比较了 "x" 和 "X" 的 SHA256 散列值。
```go
c1 := sha256.Sum256([]byte("x"))
c2 := sha256.Sum256([]byte("X"))
fmt.Printf("%x\n%x\n%t\n%T\n", c1,c2, c1==c2, c1)
// Output:
//2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
//4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
//false
//[32]uint8
```
这两个原始消息仅有一位(bit) 之差，但是他们生成的摘要信息有将近一半的位不同。注意:
上面格式化字符串 %x 表示将一个数组或者 slice 里面的字节按照 16进制的方式输出
%t 表示输出一个布尔值，%T 表示输出一个值的类型。

当调用一个函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接收的是一个副本，而不是原始参数。使用这种方式传递大的数组会变的很低效，并且在函数内部对数组的任何修改都仅影响副本，而不是原始数组。在这种情况下，Go 把数组和其他类型都看成值传递。而在其他语言中，数组是隐式的使用引用传递。
当然，也可以显示的传递一个数组的指针给函数，这样在函数内部对数组的任何修改都会反映到原始数组上面。下面的程序演示如果将一个数组[32]byte 的元素清零。
```go
package main

func main(){
	a := [32]byte{1,2,3}
	zero(&a)

}

func zero(ptr *[32]byte){
	for i := range ptr{
		ptr[i] = 0
	}
}
```
数组字面量 [32]byte{} 可以生成一个拥有 32 个字节元素的数组。数组中的每个元素的值都是字节类型的零值，即0。可以利用这一点来写另一个版本的数组清零程序。
```go
func zero(prt *[32]byte) {
    *ptr = [32]byte{}
}
```
使用数组指针是高效的，同时允许被调用函数修改调用方数组中的元素，但是因为数组长度是固定的，所以数组本身是不可变的。例如上面的 zero 函数不能接受一个 [16]byte 这样的数组指针，同样也无法为数组添加或者删除元素。由于数组的长度不可变的特性，除了在特殊的情况下，我们很少使用数组。更多的情况下，我们使用 slice

## 2. slice
slice 表示一个拥有相同类型元素的可变长度的序列。slice 通常写成 []T, 其中元素的类型都是 T，它看上去像是没有长度的数组类型。
数组和 slice 是紧密关联的。slice 是一种轻量级的数据结构，可以用来访问数组的部分或全部元素，而这个数组称为 slice 的底层数组。slice 有三个属性: 指针、长度、容量。
指针指向数组的第一个可以从 slice 中访问的元素，这个元素并不一定是数组的第一个元素。
长度是指 slice 中的元素个数，它不能超过 slice 的容量。
容量的大小通常是从 slice 的起始元素到底层数组的最后一个元素间元素的个数。
Go 内置函数 len 和 cap 用来返回 slice 的长度和容量。
一个底层数组可以对应多个 slice ，这些 slice 可以引用数组的任何位置，彼此之间的元素还可以重叠。

下图显示了一个月份名称的字符串数组和两个元素存在重叠的slice。数组的声明是:
```go
months := [...]string{1: "January", 2: "February", 3: "March",
		4: "April", 5: "May", 6: "June", 7: "July", 8: "August",
		9: "September", 10: "October", 11: "November", 12: "December"}
```
所以 January 就是 month[1], December 是 months[12]。一般来讲，数组中索引 0 的位置存放数组中第一个元素，但是月份总是从 1 开始，因此我们可以不设置索引为 0 的元素，这样它的值就是空字符串。
![slice图](1.jpg)
slice 操作符 s[i:j] (其中 0 <= i <= j <= cap(s)) 创建了一个新的 slice，这个新的 slice 引用了序列 s 中从 i 到 j-1 索引位置的所有元素，这里的 s 既可以是数组或者指向数组的指针，也可以是 slice。新 slice 的元素个数是 j-1 个。如果上面的表达式中省略了 i，那么新 slice 的起始索引位置就是 0，即 i=0；如果省略了 j ，那么新 slice 的结束索引位置是 len(s) -1,
即 j=len(s)。因此， slicemonths[1:13] 引用了所有的有效月份，同样的写法可以是 months[1:]。slicemonths[:] 引用了整个数组。接下来，我们定义元素重叠的 slice，分别用来定义第二季度的月份和北半球的夏季月份。
```go
Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2) // [April May June]
fmt.Println(summer) // [June July August]
```
元素 June 同时包含连个 slice中，使用下面的代码来输出两个 slice 的共同元素。(虽然效率不高)
```go
	for _, r := range Q2{
		for _, q := range summer {
			if r == q{
				fmt.Println(r)
			}
		}
	}
```
如果 slice 的引用超过了被引用对象的容量，即 cap(s), 那么会导致程序宕机；但是如果 slice 的引用超出了被引用对象的长度，即len(s), 那么最终 slice 会比原 slice 长。
```go
fmt.Println(summer[:20]) // 宕机，超过了被引用对象的边界。
endlessSummer := summer[:5] // 在 slice 容量范围内扩展了 slice
fmt.Println(endlessSummer) // [June July August September October]
```

另外，注意求字符串(string) 字串操作和对字节 slice ([]byte) 做 slice 操作这两者的相似性。他们都写作 x[m:n] , 并且都返回原始字节的一个子序列，同时他们底层的引用方式也是相同的，所以两个操作都消耗常量时间。区别在于: 如果 x 是字符串，那么 x[m:n] 返回的是字符串；如果 x 是字节 slice，那么返回的结果是字节 slice。
因为 slice 包含了指向数组元素的指针，所以将一个 slice 传递给函数的时候，可以在函数内部修改底层数组的元素。换言之，创建了一个数组的 slice 等于为数组创建了一个别名。下面的函数 reverse 就地反转了整型 slice 中的元素，它适用于任意整型 slice。
```go
package main

import (
	"fmt"
)

func main() {
    // 这里反转数组 a
	a := [...]int{1,2,3,4,5,6}
	reverse(a[:])
	fmt.Println(a) // [6 5 4 3 2 1]

}

func reverse(s []int) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}
```
将一个 slice 左移 n 个元素的简单办法就是连续调用 reverse 函数三次。第一次反转前 n 个元素。第二次反转剩下的元素，最后对整个 slice 再做一次反转。

注意初始化 slice s 的表达式和初始化数组 a 的表达式的区别，slice 字面量看上去和 数组字面量很像，都是用逗号分隔并用花括号括起来的一个元素序列，但是 slice 没有指定长度。这种隐式区别的结果分别是创建有固定长度的数组和创建指向数组的 slice。和数组一样，slice 也按照顺序指定元素，也可以通过索引指定元素，或者两者结合。
和数组不同的是，slice 无法做比较操作 ，因此不能使用 == 来测试两个 slice 是否拥有相同的元素。标准库里面提供了高度优化的函数 bytes.Equal 来比较两个字节 slice ([]byte) 。但是对其它类型的 slice，我们必须自己写函数来比较。
```go
package main

import "fmt"

func main() {
	a := []string{1: "1", 2: "2"}
	b := []string{1: "1", 2: "2"}
	c := []string{1: "1", 2: "1"}
	fmt.Println(equal(a,b), equal(a,c)) // true, false
}

func equal(x, y []string) bool {
	if len(x) != len(y) {
		return false
	}
	for i := range x {
		if x[i] != y[i] {
			return false
		}
	}
	return true
}
```
这种深度比较 看上去很简单，并且运行的时候并不比字符串数组使用 == 做比较多耗时间。你或许很奇怪为什么 slice 比较不可以直接使用 == 操作符做比较。这里有两个原因。
首先，和数组元素不同，slice 的元素是非直接的，有可能 slice 可以包含它自身。虽然有办法处理这种特殊的情况，但是没有一种方法是简单、高效、直观的。
其次，因为 slice 的元素不是直接的，所以如果底层数组元素改变，同一个 slice 在不同时间段会拥有不同的元素。
