[toc]
> GO程序设计语言

## 1. hello word 程序
创建 helloworld.go 文件
```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")

}

// go run .\01helloworld.go 将一个或者多个.go 为后缀的源文件进行编译、链接、然后运行生成可执行文件。
// go build .\01helloworld.go 编译成一个可复用的二进制程序, 生成01helloword.exe, 然后可以通过./01helloworld.exe执行

```

Go代码使用包来组织的，包类似于其他语言种的库或者模块，一个包由一个或者多个.go 源文件组成，放在一个文件夹中，该文件夹的名字描述了包的作用。每个源文件的开始都用package声明, 01helloworld.go 文件中，package main , 指明了这个文件属于 main 包，后面跟着它导入的其他包的列表，然后是存储在文件中的程序声明。

Go的标准库中有100个包用来完成输入、输出、排序、文本处理等常见任务。例如 fmt 包中的函数用来格式化输出和扫描输入。Println 是fmt 一个基本的输出函数，他输出一个或者多个用空格分隔符的值，结尾使用一个换行符，这样看起来这些值是单行输出。

名为 main 的包比较特殊，它用来定义一个独立的可执行程序，而不是库。在 main 包中，函数 main 也是特殊的，不管在什么程序中，main 做什么事情，它总是程序开始执行的地方。main 通常调用其他包中的函数来做更多的事情，比如fmt.Println

我们需要告诉编译器源文件需要哪些包，使用package后面的import 来导入这些包。

你必须精确的导入需要的包，不能多也不能少，否则编译会失败。

import 声明必须跟在package 之后，import 导入声明后面，是组成程序的函数、变量、常量、类型(以fun, var, const, type开头)声明。大部分情况下，声明的顺序是没有关系的。

一个函数的声明由 func 关键字、函数名、参数列表(main 函数为空)、返回值列表(可以为空)、放在大括号内的函数体组成，函数体定义函数是用来做什么的。

Go不需要在语句或声明后面使用分号(;)结尾，除非有多个语句或声明出现在同一行。
事实上，跟在特定符号后面的换行符被转换为分号了，在什么地方进行换行会影响对 Go代码的解析。例如 "{" 符号必须和关键字 func 在同一行，不能独自成行，并且在 x + y 这个表达式中，换行符可以在在 + 操作符的后面，但是不能在 + 操作符的前面。
比如表达式 x + y
可以 x + 
y

不可以 x 
+ y


Go 对于代码的格式化要求非常严格，gofmt 工具将代码以标准化格式重写，go 工具的 fmt子命令使用gofmt工具来格式化指定包里的所有文件或当前文件夹中的文件(默认情况下), 本书中包含的 Go 源代码文件都使用 gofmt 运行过。应该养成对自己代码使用gofmt工具的习惯。

许多文件编辑器可以配置为每次保存文件时自动运行gofmt, 因此源文件总能保持正确的形式，此外一个相关的工具goimports 可以按需管理导入的插入和移除。


## 2. 命令行参数
大部分程序处理输入然后产生输出，这就是关于计算的大致定义。但是程序怎样获取程序的输入呢。一些程序自己生成数据，更多的时候，输入来自一个外部的源: 文件、网络连接、其他程序的输出、键盘、命令行参数等。随后一些示例将从命令行参数开始讨论这些输入。

os 包提供一些函数和变量，以与平台无关的方式和操作系统打交道。命令行参数以 os包中的 Args 名字的变量提供程序访问，在 os 包外面，使用 os.Args 这个名字。
变量 os.Args 是一个字符串 slice 。 slice是 go的基础概念，暂时可以理解为 slice 是一个动态容量的顺序数组 s , 可以通过 s[i] 来访问单个元素，通过 s[m:n] 来访问一段连续的子区间，数组长度 len(s) 表示。Go中所有的索引 使用半开区间，即包含第一个索引，不包含最后一个索引，因为这样逻辑比较简单。例如 s[m:m] ，其中 0<= m <= n <= len(s) , 包含n-m个元素。

os.Args 的第一个元素 os.Args[0]，他是命令本身的名字，另外的元素是程序开始执行时的参数。表达式 s[m:n] 表示从第 m 个到 n-1 个元素的slice，所以下一个示例中 slice 需要的元素是 os.Args[1:len(os.Args)]。 如果 m 或者 n 缺失，默认分别是 0 或 len(s), 所以我们可以将期望的 slice 简写为 os.Args[1:], 上面说到了 os.Args[0]是程序本身。


这里有一个 unix echo 命令的实现，它将命令行参数 输出到一行。该实现导入2个包，使用用圆括号括起来的列表，而不是独立的import 声明。两者都是合法的，但是建议使用列表方式。导入的顺序是没有关系的，gofmt 工具将会按照字母顺序表进行排序(当一个示例有几个版本时，通常给他们编号以区分出当前讨论的版本)

```go
// 输出其命令行参数
package main

import (
	"fmt"
	"os"
)

func main() {
	var s, sep string
	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
}
```
注释以 // 开头。 所有以 // 开头的文本是给程序员看的注释，编译器会忽略他们，习惯上在一个包声明前，使用注释对其进行描述，对于main 包，注释是一个或多个完整的句子，用来对这个程序进行整体概括。

var 关键字声明了两个 string 类型的 变量 s 和 sep。 变量可以在声明时初始化。如果变量没有明确的初始化，它将隐式的初始化为这个类型的 空值，例如数字是0，字符串是空字符串""。在这个示例中，s 和 sep 隐式的初始化为空字符串""。

对于数字，Go提供常规的算数和逻辑操作符，当应用于字符串时， + 操作符对字符串的值进行追加操作，所以表达式
sep + os.Args[i] 表示将 sep 和 os.Args[i] 追加到一起，程序中使用语句 
s += sep + os.Args[i] 等价于 s = s + sep + os.Args[i]

操作符 += 是一个赋值操作符，每一个算术和逻辑操作符(例如 + 或者*) 都有一个对应的赋值操作符，可以是 *=

echo 程序会循环每次输出，这个版本中我们通过反复追加来构建一个字符串，字符串 s 一开始是一个空字符串 "", 每次循环追加一些文本，在第一次迭代后，一个空格被插入，这样当循环结束时，每个参数后面都有一个空格，这里需要注意的是 i++ 操作是在 sep = " " 之后i才会进行自增。如果参数数量很大成本会比较高，下面章节会进行优化。

循环的索引变量 i 在for循环开始处声明， := 符号用于短变量声明，这种语句声明一个或多个变量，并且根据初始化的值给与相应的类型。

递增语句 i++ 对 i 进行加 1， 等于加 i += 1, 又等价于 i = i + 1 ; 对应的 i-- 也是一样的。这些是语句，而不是表达式，所以 j = i++ 是错误的写法，没有 ++i 和 --i

for 是 Go 里面唯一循环语句，它有几种形式，这里暂时其中用到的一种

fo initialization; condition; post {
	// 零个或多个语句
} 

for 循环的三个组成部分两边不用小括号(), 大括号是必须的，但左大括号必须在post 之后，并且是同一行
可选的initialization(初始化)语句在循环开始之前执行，如果存在，则必须是一个简单的语句，比如一个简短的变量声明，一个递增或者赋值语句，或者一个函数调用。condition(条件) 是一个布尔表达式，在循环的每一次迭代开始前计算，如果计算结果为真，循环则继续执行。post 语句在循环体结束后执行，然后condition再次被计算，直到条件变成假之后，循环结束。
三部分都可以省略，如果没有 initialization 和 post 语句， 分号可以省略。
// 传统的while循环
for condition {
	// ...
}

如果条件都不存在
// 传统的死循环
for {
	// ...
}
循环时无限的，尽管这种循环可以通过 break 或者 return 等语句进行终止。

另一种形式的 for 循环在字符串或者 slice 数据上进行迭代。

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	var s, sep = "", ""
	for _, arg := range os.Args[1:] {
		s += sep + arg
		sep = " "
	}
	fmt.Println(s)
}
```
每一次迭代，range 产生一对值: 索引和这个索引处元素的值。在这个示例中，我们不需要索引，但是语法上 range 循环需要处理，因此也必须处理索引。一个办法是我们可以将索引赋值给一个临时变量(temp) 然后忽略它，但是 Go 不允许存在无用的临时变量，不然会出现编译错误。
解决方案是使用 空标识符, 它的名字是 _ (一个下划线)。空标识符可以用在任何语法需要变量名但是程序逻辑不需要的地方，例如丢弃每次迭代不需要的索引。大多数 Go 程序员喜欢使用 range 和 _ 来写上面的程序，因为索引在 os.Args 上面是隐式的，所以更不容易犯错误。

这个版本的程序使用短的变量声明来声明和初始化 s 和 sep， 但是我们可以等价的分开声明这个变量。以下几种声明字符串变量的方式是等价的。
```go
s := ""
var s string
var s = ""
var s string = ""
```
第一种形式的短变量声明更加简洁，但是通常在一个函数内部使用，不适合 包级别的变量。
第二种形式依赖默认初始化为空字符串的 ""。
第三种形式很少用，除非我们声明多个变量。
第四种形式是显示的变量类型，在类型一致的情况下是冗余的信息，在类型不一致的情况下是必须的。
实践中，我们应该使用前两种形式，使用显示的初始化来说明初始化变量的重要性，使用隐式的初始化来表明初始化变量不重要。


如上所属，每次循环，字符串 s 有了新的内容，+= 语句通过追加旧字符串、空格字符串和下一个参数，生成一个新的字符串。然后把新字符串赋值给 s， 旧的内容不在需要使用，会被例行垃圾回收。
如果有大量的数据需要处理，这样的代价会比较大，一个简单高效的方式是使用 strings 包中的 Join函数

```go
package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	fmt.Println(strings.Join(os.Args[1:], " "))
}
```

最后，如果不关心格式，只是想看值，那么可以直接 fmt.Println(os.Args[1:])
这个输出语句和我们从strings.Join 得到的很像，不过两边有括号, 任何 slice 都可以这样输出。


## 3. 找出重复的行

