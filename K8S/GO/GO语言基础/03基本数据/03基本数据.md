[toc]

基本数据

毫无疑问，计算机底层全是位，而实际操作则是基于大小固定的单元中的数值，称为字(word), 这些值可解释为整数、浮点数、位集(bitset)或内存地址等，进而构成更大的聚合体，以表示数据包、像素、文件、诗集，以及其他种种。Go 的数据类型宽泛，并有多种组织方式，向下匹配硬件特性，向上满足程序员需求，从而可以方便的表示复杂的数据结构。
Go 的数据类型可以分为四大类: 基础类型(basic type)、聚合类型(aggregate type)、引用类型(refrence type) 和 接口类型(interface type)。本章的主题是基础类型，包括数字(number)、字符串(string)和布尔型(boolean)。聚合类型--数组和结构体是通过组合各种简单的类型得到更复杂的数据类型。引用是一大分类，其中包含很多不同类型，如指针、slice、map、函数基于通道。他们的共同点是全都间接指向程序变量或状态，于是操作所引用的数据的效果就会遍及该数据的全部引用。

# 1. 整数
Go 的数值类型包含了几种不同大小的整数、浮点数和复数。各种数值类型有自己的大小，对正负号支持也各异。我们从整数开始。

Go 同时具备有符号整数和无符号整数。有符号整数分四种大小: 8位，16位，32位，64位，用 int8, int16, int32, int64表示，对应的无符号整数是 uint8, uint16, uint32, uint64。

此外还有两种类型的 int 和 uint。在特定平台上，其大小与原生的有符号整数\无符号整数相同，或等于该平台上的运算效率最高的值。int 是目前使用最广泛的数值类型。这两种类型大小相等，都是32位或64位，但不能认为他们一定是32位，或一定是64位; 即使在同样的硬件平台上，不同的编译器可能选择不同的大小。

rune 类型是 int32 类型的同义词，常常用于指明一个值是 Unicode 码点(code point)。这两个名称可以互换使用。
同样byte 类型是 uint8 类型的同义词，强调一个值是原始数据，而非量值。

最后，还有一中无符号整数 uintptr ， 其大小并不明确，但足以完整存放指针。uintptr 类型仅仅用于底层编程，例如在 Go 程序与 C 程序库或操作系统的接口界面。

int 、uint 和 uintptr 都有别于 其 大小明确的相似类型的类型。就是说， int 和 int32 是不同类型，尽管 int 天然的大小是32 位，但是 int 值 若要当作 int32 使用，必须显示转换，反之亦然。

有符号整数以补码表示，保留最高位作为符号位，n 位数字的取值范围是 -2 ^n-1 ~ 2^n-1 -1, 无符号整数由全部位构成其非负值，范围是 0 ~ 2^n -1 , 例如 int8 可以从 -128~127 取值，而uint8 0~255 取值。

Go 的二位操作符涵盖了算术、逻辑和比较运算。按优先级的降序排列如下: 
*   /   %   <<  >>  &   &^
+   -   |   ^   
==  !=  <   <=  >   >=
&&
||

二元运算符分五大优先级。同级别的运算符满足左结合律，为求清晰，可能需要圆括号，或 为使表达式内的运算符按指定次序运算，如 mask & (1<<28)
上述列表中前两行的运算符(如加法运算+) 都有对应的赋值运算符(如 +=)，用于简写赋值语句。

算术运算符 +、-、*、/ 可应用于整数、浮点数和复数，而取模运算符 % 仅能用于整数。
取模运算符 % 的行为 因编程语言而异。就 Go 语言，取模余数的 正负号总是与被除数一致，于是 -5%3 和 -5%-3 都得 -2。
除法运算 /  的行为取决于操作数是否都是整数，整数相除，商会舍弃小数部分，于是 5.0/4.0 得到1.24，而 5/4 结果是1
```go
fmt.Println(5/4) // 1
fmt.Println(5/4.0) // 1.25
fmt.Println(5.0/4.0) // 1.25
fmt.Println(5.0/4) // 1.25
```
不论是有符号数还是无符号数，若表示算术运算结果所需的位超出该类型的范围，就称为 溢出，溢出的高位部分会无提示的丢弃。假如原本的计算结果是有符号类型，且最左侧位是 1，则会形成负值。以 int8 为例：
```go
package main

import "fmt"

var u uint8 = 255
var i int8 = 127
func main(){
	fmt.Println(u, u+1, u*u) // 255, 0, 1
	fmt.Println(i, i+1, i*i) // 127, -128, 1
}
```
下列二元比较运算符用于比较两个类型相同的整数，比较表达式本身的类型是布尔型。
==  等于
!=  不等于
<   小于
<=   小于等于
>   大于
>=   大于等于

实际上，全部基本类型的值(布尔值，数值，字符串)都可以比较，这意味着两个相同类型的值可用 == 和 != 运算符比较。整数、浮点数和字符串还能根据比较运算符排序。许多其他类型的值是无法比较的，也无法排序。后面介绍每种类型时，我们将分别说明比较规则。
对于整数， +x 是 0+x 的简写，而 -x 是 0-x 的简写。对于浮点数和复数，+x 就是x，-x 是为 x 的复数。
Go 也具备下列位运算符，前 4 个对操作数的运算逐位独立进行，不涉及算术进位或正负号。
&   位运算 AND
|   位运算 OR
^   位运算符XOR，异或
    1^1=0 
　　0^0=0 
　　1^0=1 
　　0^1=1 

&^  位清空 (AND NOT)
<<  左移
>>  右移

如果作为二元运算符，运算符 ^ 表示按位 异或; 若作为一元前缀运算符，则它表示按位取反或按位取补，运算结果就是操作数逐位取反。运算符 &^ 是按位清除: 表达式 z = x &^ y 中，若 y 某位 是 1，则 z 对应位 是 0；否则它就等于 x 的对应位。

&^
解释：如果运算符右侧数值的第 i 位为 1，那么计算结果中的第 i 位为 0；如果运算符右侧数值的第 i 位为 0，那么计算结果中的第 i 位为运算符左侧数值的第 i 位的值。
```go
func main() {
    x := 11
    y := (1 << 0) | (1 << 3) //保证 z 中的第 0 位和第 3 位为 0
    z := x &^ y
​
    fmt.Printf("x = %b\n", x)
    fmt.Println("\t\t&^")
    fmt.Printf("y = %b\n", y)
    fmt.Println("————————")
    fmt.Printf("z = %04b\n", z)
}

// 运算结果:
x = 1011
        &^
y = 1001
————————
z = 0010
结果说明：

x = 11 = 1011。由于 y 中的第 0 位和第 3 位为 1，因此 z 中的第 0 位和第 3 位为 0。y 中的第 1 位和第 2 位为 0，因此，z 中第 1 位和第 2 位的值为 x 中第 1 位和第 2 位的值——1 和 0。所以 z 的值为 0010。

运算符作用
保证数值中的某些位一定为 0。
```

左移: <<
用来将一个数的各二进制位全部左移若干位。例如：
左移运算符
左移运算符(3张)
将a的二进制数左移2位，右补0。若a=15，即二进制数00001111，左移2位得00111100，即十进制数60（为简单起见，用8位二进制数表示十进制数15，如果用16位二进制数表示，结果是一样的）。
高位左移后溢出，舍弃。
左移一位相当于该数乘以2，左移2位相当于该数乘以2^2=4。上面举的例子15<< 2=60，即乘了4。但此结论只适用于该数左移时被溢出舍弃的高位中不包含1的情况。
例如，假设以一个字节（8位）存一个整数，若a为无符号整型变量，则a=64，即二进制数01000000时，左移一位时溢出的是0。而左移2位时，溢出的高位中包含1，则不符合上述结论。 [2] 
由下表可以看出，若a的值为64，在左移一位后相当于乘2，左移2位后，值等于256。
a的值
a的二进制形式
a<<1
a<<2
64
01000000
10000000
00000001,00000000
127
01111111
11111110
00000001,11111100

右移运算符，移位运算符的一种：程序设计中，位操作运算符的一种。在c++中，移位运算符有双目移位运算符：<<（左移）和>>（右移）。移位运算符组成的表达式也属于算术表达式，其值为算术值。左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补0。右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位或者一律补0，或者补符号位，这由不同的机器而定。在使用补码作为机器数的机器中，正数的符号位为0，负数的符号位为1。

下面的代码说明了如何用位运算将一个 uint8 值作为位集(bitset)处理，其含有8个独立的位，高效且紧凑。Printf 用谓词 %b 以二进制形式输出数值。副词08 在这个输出结果前补零，补够8位


```go
package main

import "fmt"

var x uint8 = 1<<1 | 1<<5
var y uint8 = 1<<1 | 1<<2

func main() {
	fmt.Println(x)          // 34
	fmt.Printf("%08b\n", x) // 00100010, 集合 {1, 5}
	fmt.Printf("%08b\n", y) // 00000110, 集合 {1, 2}
	fmt.Printf("%08b\n", x&y) // 00000010, 交集 {1}
	fmt.Printf("%08b\n", x|y) // 00100110, 并集 {1, 2, 5}
	fmt.Printf("%08b\n", x^y) // 00100100, 对称差 {2, 5}
	fmt.Printf("%08b\n", x&^y) // 00100000, 差集 {5}
	// 解释：如果运算符右侧数值的第 i 位为 1，那么计算结果中的第 i 位为 0；
	// 如果运算符右侧数值的第 i 位为 0，那么计算结果中的第 i 位为运算符左侧数值的第 i 位的值。
	for i := uint(0); i <8;i++{
		if x&(1<<i) != 0{ // 元素判定，判断 x 位为1的位置
			fmt.Println(i) // "1" , "5"
		}
	}
	fmt.Printf("%08b\n", x<<1) // 01000100
	fmt.Printf("%08b\n", x>>1) // 00010001

}

```
```shell
在位移运算 x<<n 和 x >> n 中 , 操作数 n 决定位移量，而且 n 必须为 无符号型；操作数 x 可以是有符号性也可以是无符号型，
算术上，左移运算 x << n 等价于 x 乘以 2^n ; 而右移等价于 x 除以 2^n ,向下取整。
左移以 0 填补右边空位，无符号整数右移同样以0 填补左边空位，但有符号的右移操作是按照符号位的值填补空位。因此，请注意，如果将整数以位模式处理，须使用无符号整型。

尽管 Go 具备无符号整型数和相关算术运算，也尽管某些量值不可能为负，但是我们往往还采用有符号整型数，如数组的长度(即使直观上明显更应该选用uint), 下面的例子从后向前输出奖牌名称，循环里用到了内置函数len，它返回有符号整数。
```
```go
medale := []string{"gold", "sliver", "bronze"}
for i := len(medale) - 1; i >= 0; i-- {
    fmt.Println(medale[i]) // "bronze", "sliver", "gold"
}
```
相反，假若 len 返回的是一个无符号整型，就会导致严重的错误，因为 i 随之也称为 uint 类型，根据定义，条件 i >=0 将恒成立，第3轮迭代后，语句 i-- 使得 i 变成了 uint 类型的最大值(例如，可能是 2^64 -1)， 而非 -1，导致 madale[i] 试图越界访问元素，超出 slice的范围，引发运行失败或宕机。

因此，无符号整数往往只用于位运算符和特定算术运算符，如实现位集时，解析二进制格式的文件，或散列和加密。一般而言，无符号整数极少表示非负数。

通常，将某种类型的值转换成另一种，需要显示转换。对于算术和逻辑(不含位移)的二元运算符，其操作数的类型必须相同。虽然这有时会导致表达式相对冗长，但是一整类错误得以避免，程序也更容易理解。

考虑下面的语句，它与某些场景类似。
```go
var apples int32 = 1
var oranges int16 = 2
var compote int = apples + oranges // 编译错误，类型不一致
```
尝试编译这三个声明将产生错误信息:
非法操作: apples + oranges (int32 和 int16 类型不匹配)
类型不匹配的问题有几种方法改进，最直接的，将全部操作数该成同一类型。
```go
var compote = int(apples) + int(oranges)
```

对于每种类型 T ,若允许转换，操作 T(x) 会将 x 的值转换成类型 T 。
很多整型-- 整型转换不会引起值的变化，仅告知编译器应如何解读该值。不过，缩减大小的整型转换，以及整型与浮点型的相互转换，可能改变值或损失精度。
```go
f := 3.141 // a float64
i := int(f)
fmt.Println(f, 1) // 3.141, 3
f := 1.99
fmt.Println(int(f)) // 1
```
浮点型转换成整型，会舍弃小数部分，正值向下取整，负值向上取整
```go
package main

import "fmt"

func main() {

	f := 3.141
	fmt.Printf("%T\n", f) // float64
	a := -1.12
	fmt.Println(int(a)) // -1
}
```
如果有些转换的操作数的值超出了目标类型的取值范围，就应当避免这种转换，因为其行为依赖具体实现。
```go
package main

import "fmt"

func main() {
	f := 1e100 // a float64
	i := int(f)
	fmt.Println(i) // -9223372036854775808
}
```
不论有无大小和符号的限制，源码中的整数都能写成常见的十进制; 也可以写成八进制数，以 0 开头，如 0666; 还可以写成十六进制数, 以 0x 或 0X开头，如 0xabc 。十六进制的数字(或字母)大小写都可以。当前，八进制数似乎仅有一种用途---表示POSIX 文件系统的权限，而十六进制数广泛用于强调其模式，而非数值大小。

如下列所示：如果我们使用 fmt 包输出数字，我们可以用 %d, %o 和 %x 指定进制数
```go
package main

import "fmt"

func main() {
	o := 0666
	fmt.Printf("%d %[1]o %#[1]o\n", o) //438 666 0666
	x := int64(0xdeadbeef)
	fmt.Printf("%d %[1]x %#[1]X\n", x) //3735928559 deadbeef 0XDEADBEEF
}
```
通常Printf 的格式化字符串含有多个 % 谓词，这要求提供相同数目的操作数，而 % 后面的 副词[1] 告诉Printf 重复使用第一个操作数，其次，%o , %x, 或 %X 之前的副词 # 告诉 Printf 输出相应的前缀 0， 0x，0X

源码中，文字符号(rune literal) 的形式是字符写在一对 单引号内。最简单的例子就是 ASCII 字符， 如 'a' ，但也可以使用 Unicode 码点(codepoint) 或 码值转移。
用 %c 输出文字符号，如果希望输出带有单引号的则 用 %q
```go
package main

import "fmt"

func main() {
	ascii := 'a'
	unicode := '国'
	newline := '\n'
	fmt.Printf("%d %[1]c %[1]q\n", ascii) // 97 a 'a'
	fmt.Printf("%d %[1]c %[1]q\n", unicode) // 22269 国 '国'
	fmt.Printf("%d  %[1]q\n", newline) //  10  '\n'
}
```


## 2. 浮点数
Go 具有两种大小的浮点数 float32 和 float64, 其算术标准遵循从 IEEE 754 标准，所有新式 CPU 都支持该标准。
这两个类型的值可以从超细微到超宏大。math 包给出了 浮点值的极限。常量 math.MaxFloat32 是 float32 的最大值，大约3.4e38, 而 math.MaxFloat64 则大约是 1.8e308, 相应的，最小的正浮点值大约是 1.4e-45, 和 4.9e-324

十进制下，float32 的有效数字大约是 6位，float64 有效数字大约是15位。绝大多数的情况下，应优先选用 float64，因为除非格外小心，否则 float32 的运算会迅速积累误差。另外，float32 能精确表示的正整数范围有限。

```go
package main

import "fmt"

var f float32 = 16777216

func main() {
	fmt.Println(f == f+1) // true
}
```
在源码中，浮点数可写成小数，如:
```go
const e = 2.71828 // 近似值
```
小数点前的数字可以省略(例如: 0.121, 可以写成 .121) ,后面也可以省略(1.0 可以写成 1.)。非常小或者非常大的数字最好使用科学计数法表示，次方法在数量级指数前写字母 e 或者 E:
```go
const avo = 6.02212e23
const bvo = 6.6E23
```
浮点值能方便的通过 Printf 的谓词 %g(根据情况选择 %e 或 %f 以产生更紧凑的) 输出，该谓词会自动保持足够的精度，并选择最简介的表示方式，但是对于数据表 %e(有指数) 或者 %f(无指数)的形式更加合适。这三个谓词都能掌控输出宽度和数值精度。
```go
package main

import (
	"fmt"
	"math"
)

func main() {
	for x := 0; x < 8; x++ {
		fmt.Printf("x = %d e = %8.3f\n", x, math.Exp(float64(x)))
	}
}

输出:
x = 0 e =    1.000
x = 1 e =    2.718
x = 2 e =    7.389
x = 3 e =   20.086
x = 4 e =   54.598
x = 5 e =  148.413
x = 6 e =  403.429
x = 7 e = 1096.633
其中:
%8.3f表示 按 8 个字符的宽度输出自然对数 e 的各个幂方，结果保留三位小数
```
除了大量常见的数学函数外，math 包还有函数用于创建和判断 IEEE 754 标准定义的特殊值: 正无穷大和负无穷大，它表示超出最大许可制的数及除以零的商；以及 NaN (Not a Number) ，它表示数学上无意义的运算结果(如 0/0 或 sqrt(-1))
```go
package main

import "fmt"

var z float64
func main() {
	fmt.Println(z, -z, 1/z, -1/z, z/z) // 0 -0 +Inf -Inf NaN
}
```
math.IsNaN 函数判断其参数是否是非数值，math.NaN 函数则返回非数值(NaN) 。 在数字运算中，我们倾向于将 NaN当作信号值(sentinel value) , 但是直接判断具体的计算结果是否为 NaN 可能导致潜在的错误，因为 与 NaN 的比较总不成立(除了 != , 它总是与 == 相反)
```go
package main

import (
	"fmt"
	"math"
)

var z float64
func main() {
	nan := math.NaN()
	fmt.Println(nan == nan, nan < nan, nan > nan, nan != nan) // false false false true
}
```
一个函数的返回值是浮点型且它有可能出错，那么最好单独报错，如下:
```go
func compute() (value float64, ok bool) {
    // ...
    if failed {
        return 0, false
    }
    return result, true
}
```


## 3. 复数
略


## 4. 布尔值
bool 型的值或布尔值(boolean) 只有两种可能: 真(true) 和 假(false) 。 if 和 for 语句里的条件就是布尔值，比较操作符(如 == 和 <) 也可能得出布尔值结果。一元操作符(!) 表示逻辑取反，因此 !true 就是false， !true == false, 考虑到代码风格上，布尔表达式 x==true 相对冗长，我们总简化为 x 。
布尔值可以有运算符&&(AND) 和 ||(OR) 组合运算，这可能引起短路行为: 如果运算符左边的操作数已经能直接确定结果，则右边的操作数不会计算在内，所以下面的表达式总是安全的。
```go
s != "" && s[0] == 'x'
```
其中，如果s 是空字符串，则 s[0]会触发宕机异常。
因为 && 比 || 优先级更高，所以如下形式的条件无需加括号
```go
if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || '0' <= c && c <= '9' {...}
```
布尔值无法隐式的转换成数值(如0 或 1)，反之也不行。如下状况下就有必要使用显示 if:
```go
i := 0
if b {
    i = 1
}
```

假如转换操作常常用到，就需要写个转换函数了
```go
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}
```
```go
func itob(i int) bool {
    return i != 0 // 如果 i为0 ，return false， 否则返回true
}
```

## 5. 字符串
字符串是不可变的字节序列，它可以包含任意数据，包括 0 值字节，但主要是人类可读的文本。习惯上，文本字符串被解读成按 UTF-8 编码的 Unicode 码点(文字符号) 序列。

内置的 len 函数返回字符串的字节数(并非文字符号的数目), 下标访问操作 s[i] 则取第 i 个字符，其中 0 <= i <= len(s)
```go
package main

import "fmt"

func main() {
	s := "hello, world"
	fmt.Println(len(s)) // 12
	fmt.Println(s[0], s[7]) // 104, 119
	fmt.Printf("%c, %c" , s[0], s[7]) // h, w
}
```
试图访问许可范围以为的字节会触发宕机异常。
```go
c := s[len(s)] // 宕机: 下标越界
```
字符串的第 i 个字节不一定就是第 i 个字符，因为 非 ASCII 字符的 UTF-8 码点需要两个字节或多个字节。
子串生成操作 s[i:j] 产生一个新字符串，内容取自原字符串的字节，下标从 i(含边界值) 开始，直到 j(不含边界值)结束。结果大小是 j-i 个字节。
```go
fmt.Println(s[0:5]) // hello
```
如果下标越界，或者 j 的值小于 i，将触发宕机异常。
操作数 i 和 j 的默认值分别是 0(从字符串起始位置)和 len(s) (字符串终止位置)，若省略 i 或 j，或两者都省略，则取默认值。
```go
fmt.Println(s[:5]) // hello
fmt.Println(s[7:]) // world
fmt.Println(:) // hello, world
```
加号(+) 运算符连接两个字符串而生成一个新字符串: 
```go
fmt.Println("goodbye" + s[5:]) // goodbye, world
```
字符串可以通过比较运算符做比较，如 == 或 < ; 比较运算符按字节进行，结果服从本身的字典排序。